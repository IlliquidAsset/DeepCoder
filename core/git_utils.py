"""
Git utilities for DeepCoder CLI.
"""
import os
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import git

logger = logging.getLogger("deepcoder.git")


class GitError(Exception):
    """Exception raised for Git-related errors."""
    pass


class GitManager:
    """Manages Git operations for the DeepCoder agent."""
    
    def __init__(self, project_root: Path):
        """
        Initialize the Git manager.
        
        Args:
            project_root: The root directory of the project
        """
        self.project_root = project_root
        self._repo = None
        
        try:
            self._repo = git.Repo(project_root)
        except git.InvalidGitRepositoryError:
            # Not a Git repository, that's okay
            logger.debug(f"{project_root} is not a Git repository")
        except Exception as e:
            logger.warning(f"Error initializing Git repository: {str(e)}")
    
    def is_git_repo(self) -> bool:
        """
        Check if the project is a Git repository.
        
        Returns:
            bool: True if the project is a Git repository
        """
        return self._repo is not None
    
    def get_status(self) -> Dict[str, List[str]]:
        """
        Get the Git status of the project.
        
        Returns:
            Dict: Dictionary containing status information
            
        Raises:
            GitError: If Git status cannot be retrieved
        """
        if not self.is_git_repo():
            return {
                "untracked": [],
                "modified": [],
                "staged": []
            }
        
        try:
            untracked = []
            modified = []
            staged = []
            
            for item in self._repo.index.diff(None):
                modified.append(item.a_path)
            
            for item in self._repo.index.diff("HEAD"):
                staged.append(item.a_path)
            
            for item in self._repo.untracked_files:
                untracked.append(item)
            
            return {
                "untracked": untracked,
                "modified": modified,
                "staged": staged
            }
        except Exception as e:
            logger.error(f"Error getting Git status: {str(e)}")
            raise GitError(f"Failed to get Git status: {str(e)}")
    
    def stage_file(self, file_path: str) -> None:
        """
        Stage a file for commit.
        
        Args:
            file_path: Path to the file to stage
            
        Raises:
            GitError: If the file cannot be staged
        """
        if not self.is_git_repo():
            raise GitError("Not a Git repository")
        
        try:
            # Convert to relative path if absolute
            if os.path.isabs(file_path):
                rel_path = os.path.relpath(file_path, self.project_root)
            else:
                rel_path = file_path
            
            self._repo.git.add(rel_path)
        except Exception as e:
            logger.error(f"Error staging file {file_path}: {str(e)}")
            raise GitError(f"Failed to stage file {file_path}: {str(e)}")
    
    def commit_changes(self, message: str) -> str:
        """
        Commit staged changes.
        
        Args:
            message: Commit message
            
        Returns:
            str: The commit hash
            
        Raises:
            GitError: If the commit fails
        """
        if not self.is_git_repo():
            raise GitError("Not a Git repository")
        
        try:
            # Add a signature to the commit message
            full_message = f"{message}\n\nGenerated by DeepCoder CLI"
            commit = self._repo.index.commit(full_message)
            return commit.hexsha
        except Exception as e:
            logger.error(f"Error committing changes: {str(e)}")
            raise GitError(f"Failed to commit changes: {str(e)}")
    
    def is_file_ignored(self, file_path: str) -> bool:
        """
        Check if a file is ignored by Git.
        
        Args:
            file_path: Path to the file to check
            
        Returns:
            bool: True if the file is ignored
        """
        if not self.is_git_repo():
            return False
        
        try:
            # Convert to relative path if absolute
            if os.path.isabs(file_path):
                rel_path = os.path.relpath(file_path, self.project_root)
            else:
                rel_path = file_path
            
            return self._repo.ignored(rel_path)
        except Exception as e:
            logger.warning(f"Error checking if file {file_path} is ignored: {str(e)}")
            return False